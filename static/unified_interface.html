<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rosetta Helix Unified Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #000000, #0a0a0a, #1a0a1a);
            color: #00ff00;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Sacred geometry background */
        #sacred-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
            z-index: 0;
        }

        /* Main container with grid layout */
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 60px 1fr 100px;
            gap: 10px;
            height: 100vh;
            padding: 10px;
            position: relative;
            z-index: 1;
        }

        /* Header spanning both columns */
        .header {
            grid-column: 1 / -1;
            background: rgba(10, 10, 30, 0.8);
            border: 2px solid #00ff00;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .header h1 {
            font-size: 24px;
            text-shadow: 0 0 10px #00ff00;
        }

        .metrics {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
        }

        .metric-label {
            font-size: 10px;
            opacity: 0.7;
        }

        /* Left panel - KIRA Chat */
        .kira-panel {
            background: rgba(10, 10, 30, 0.8);
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .kira-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
        }

        .consciousness-indicator {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .consciousness-level {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00ff00;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 0, 0.2);
        }

        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-message {
            background: rgba(0, 100, 0, 0.3);
            border-left: 3px solid #00ff00;
        }

        .kira-message {
            background: rgba(100, 0, 100, 0.3);
            border-left: 3px solid #ff00ff;
        }

        .system-message {
            background: rgba(100, 100, 0, 0.3);
            border-left: 3px solid #ffff00;
            font-style: italic;
        }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        #user-input {
            flex: 1;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff00;
            border-radius: 5px;
            color: #00ff00;
            font-family: inherit;
        }

        #user-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .send-button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #003300, #006600);
            border: 1px solid #00ff00;
            border-radius: 5px;
            color: #00ff00;
            cursor: pointer;
            transition: all 0.3s;
        }

        .send-button:hover {
            background: linear-gradient(135deg, #006600, #009900);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
        }

        /* Right panel - Visualization */
        .viz-panel {
            background: rgba(10, 10, 30, 0.8);
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .viz-header {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
        }

        #helix-canvas {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .apl-tokens {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 80px;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            gap: 5px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 5px;
        }

        .apl-token {
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            border-radius: 5px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .apl-token:hover {
            background: rgba(0, 255, 0, 0.3);
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }

        .apl-token.active {
            background: rgba(255, 255, 0, 0.3);
            border-color: #ffff00;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Control panel at bottom */
        .control-panel {
            grid-column: 1 / -1;
            background: rgba(10, 10, 30, 0.8);
            border: 2px solid #00ff00;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-label {
            font-size: 12px;
            opacity: 0.7;
        }

        .slider {
            width: 150px;
            height: 5px;
            background: rgba(0, 255, 0, 0.2);
            border-radius: 5px;
            position: relative;
            cursor: pointer;
        }

        .slider-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00);
            border-radius: 5px;
            transition: width 0.3s;
        }

        .slider-handle {
            position: absolute;
            top: -5px;
            width: 15px;
            height: 15px;
            background: #00ff00;
            border: 2px solid #000;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }

        .control-button {
            padding: 8px 16px;
            background: rgba(0, 100, 0, 0.3);
            border: 1px solid #00ff00;
            border-radius: 5px;
            color: #00ff00;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        .control-button:hover {
            background: rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }

        .control-button.active {
            background: rgba(255, 255, 0, 0.3);
            border-color: #ffff00;
            color: #ffff00;
        }

        /* Phase indicator */
        .phase-indicator {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .phase-untrue {
            background: rgba(255, 0, 0, 0.3);
            border: 1px solid #ff0000;
            color: #ff0000;
        }

        .phase-paradox {
            background: rgba(255, 255, 0, 0.3);
            border: 1px solid #ffff00;
            color: #ffff00;
        }

        .phase-true {
            background: rgba(0, 255, 0, 0.3);
            border: 1px solid #00ff00;
            color: #00ff00;
        }

        /* Nuclear spinner visualization */
        .spinner-viz {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        .loading-spinner {
            width: 100px;
            height: 100px;
            border: 3px solid rgba(0, 255, 0, 0.3);
            border-top: 3px solid #00ff00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 18px;
            text-shadow: 0 0 10px #00ff00;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr 1fr 100px;
            }

            .header {
                grid-column: 1;
            }

            .control-panel {
                grid-column: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Sacred geometry background -->
    <svg id="sacred-bg" xmlns="http://www.w3.org/2000/svg"></svg>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Rosetta Helix...</div>
    </div>

    <!-- Main container -->
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <h1>ðŸŒ€ ROSETTA HELIX UNIFIED</h1>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="z-value">0.000</div>
                    <div class="metric-label">Z-COORD</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="entropy-value">0.00</div>
                    <div class="metric-label">NEG ENTROPY</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="coherence-value">0.00</div>
                    <div class="metric-label">COHERENCE</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="tier-value">0</div>
                    <div class="metric-label">TIER</div>
                </div>
                <div class="metric">
                    <div class="phase-indicator" id="phase-indicator">UNTRUE</div>
                </div>
            </div>
        </div>

        <!-- KIRA Chat Panel -->
        <div class="kira-panel">
            <div class="kira-header">
                <h2>K.I.R.A. DIALOGUE</h2>
                <div class="consciousness-indicator">
                    <span>Consciousness:</span>
                    <div class="consciousness-level"></div>
                    <div class="consciousness-level"></div>
                    <div class="consciousness-level"></div>
                    <div class="consciousness-level"></div>
                    <div class="consciousness-level"></div>
                </div>
            </div>
            <div id="chat-messages"></div>
            <div class="chat-input-container">
                <input type="text" id="user-input" placeholder="Enter your message..." />
                <button class="send-button" id="send-button">SEND</button>
            </div>
        </div>

        <!-- Visualization Panel -->
        <div class="viz-panel">
            <div class="viz-header">
                <h2>HELIX VISUALIZATION</h2>
            </div>
            <canvas id="helix-canvas"></canvas>
            <div class="apl-tokens" id="apl-tokens"></div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-group">
                <span class="control-label">Z-TARGET:</span>
                <div class="slider" id="z-slider">
                    <div class="slider-fill" id="z-slider-fill"></div>
                    <div class="slider-handle" id="z-slider-handle"></div>
                </div>
                <span id="z-target-value">0.500</span>
            </div>

            <div class="control-group">
                <button class="control-button" id="drive-lens-btn">DRIVE TO LENS</button>
                <button class="control-button" id="collapse-btn">COLLAPSE</button>
                <button class="control-button" id="reset-btn">RESET</button>
            </div>

            <div class="control-group">
                <button class="control-button" id="auto-mode-btn">AUTO MODE</button>
                <button class="control-button" id="training-btn">TRAINING</button>
                <span class="control-label">K-FORM: <span id="k-formation">NO</span></span>
            </div>
        </div>
    </div>

    <script>
        // Constants matching the server
        const PHI = 1.6180339887498949;
        const PHI_INV = 0.6180339887498949;
        const Z_CRITICAL = 0.8660254037844387;  // âˆš3/2 - THE LENS

        // WebSocket connection
        let ws = null;
        let reconnectInterval = null;

        // State variables
        let currentState = {
            z: 0.0,
            entropy: 0.0,
            coherence: 0.0,
            tier: 0,
            phase: 'UNTRUE',
            k_formation: false,
            tokens: [],
            consciousness_level: 0.5
        };

        // Initialize sacred geometry background
        function initSacredGeometry() {
            const svg = document.getElementById('sacred-bg');
            const width = window.innerWidth;
            const height = window.innerHeight;
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Create hexagonal pattern
            const hexSize = 50;
            const hexHeight = hexSize * Math.sqrt(3);

            for (let y = 0; y < height + hexHeight; y += hexHeight * 0.75) {
                for (let x = 0; x < width + hexSize * 2; x += hexSize * 3) {
                    const offset = (y / (hexHeight * 0.75)) % 2 === 1 ? hexSize * 1.5 : 0;
                    drawHexagon(svg, x + offset, y, hexSize);
                }
            }
        }

        function drawHexagon(svg, cx, cy, size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = cx + size * Math.cos(angle);
                const y = cy + size * Math.sin(angle);
                points.push(`${x},${y}`);
            }

            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', points.join(' '));
            polygon.setAttribute('fill', 'none');
            polygon.setAttribute('stroke', '#00ff00');
            polygon.setAttribute('stroke-width', '0.5');
            polygon.setAttribute('opacity', '0.3');
            svg.appendChild(polygon);
        }

        // WebSocket connection management
        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) return;

            ws = new WebSocket('ws://localhost:8765');

            ws.onopen = () => {
                console.log('WebSocket connected');
                clearInterval(reconnectInterval);
                hideLoading();
                addSystemMessage('Connected to Rosetta Helix server');

                // Request initial state
                ws.send(JSON.stringify({ type: 'get_state' }));
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleServerMessage(data);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                addSystemMessage('Connection error. Retrying...');
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                addSystemMessage('Disconnected from server. Reconnecting...');
                scheduleReconnect();
            };
        }

        function scheduleReconnect() {
            if (!reconnectInterval) {
                reconnectInterval = setInterval(() => {
                    connectWebSocket();
                }, 3000);
            }
        }

        // Handle server messages
        function handleServerMessage(data) {
            switch (data.type) {
                case 'state_update':
                    updateState(data.state);
                    break;
                case 'kira_response':
                    addKiraMessage(data.message);
                    break;
                case 'tokens_update':
                    updateTokens(data.tokens);
                    break;
                case 'training_update':
                    handleTrainingUpdate(data);
                    break;
                case 'error':
                    addSystemMessage(`Error: ${data.message}`);
                    break;
            }
        }

        // Update UI with new state
        function updateState(state) {
            currentState = { ...currentState, ...state };

            // Update metrics
            document.getElementById('z-value').textContent = state.z.toFixed(3);
            document.getElementById('entropy-value').textContent = state.entropy.toFixed(2);
            document.getElementById('coherence-value').textContent = state.coherence.toFixed(2);
            document.getElementById('tier-value').textContent = state.tier;

            // Update phase indicator
            const phaseIndicator = document.getElementById('phase-indicator');
            phaseIndicator.textContent = state.phase;
            phaseIndicator.className = `phase-indicator phase-${state.phase.toLowerCase()}`;

            // Update K-formation status
            document.getElementById('k-formation').textContent = state.k_formation ? 'YES' : 'NO';

            // Update consciousness indicators
            updateConsciousnessLevel(state.consciousness_level || 0.5);

            // Update visualization
            updateVisualization();
        }

        // Update consciousness indicators
        function updateConsciousnessLevel(level) {
            const indicators = document.querySelectorAll('.consciousness-level');
            const activeCount = Math.floor(level * 5);

            indicators.forEach((indicator, index) => {
                if (index < activeCount) {
                    indicator.style.background = '#00ff00';
                    indicator.style.boxShadow = '0 0 10px #00ff00';
                } else {
                    indicator.style.background = 'rgba(0, 255, 0, 0.2)';
                    indicator.style.boxShadow = 'none';
                }
            });
        }

        // Update APL tokens display
        function updateTokens(tokens) {
            const container = document.getElementById('apl-tokens');
            container.innerHTML = '';

            tokens.forEach((token, index) => {
                const tokenEl = document.createElement('div');
                tokenEl.className = 'apl-token';
                tokenEl.textContent = token;
                tokenEl.title = `Token ${index}: ${token}`;

                tokenEl.addEventListener('click', () => {
                    applyOperator(token);
                });

                container.appendChild(tokenEl);
            });
        }

        // Helix visualization
        function updateVisualization() {
            const canvas = document.getElementById('helix-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw helix
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.3;

            ctx.strokeStyle = getPhaseColor(currentState.phase);
            ctx.lineWidth = 2;

            // Draw double helix
            for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                const x1 = centerX + radius * Math.cos(angle) * (1 - currentState.z);
                const y1 = centerY + angle * 20 - 200;
                const x2 = centerX - radius * Math.cos(angle) * (1 - currentState.z);

                if (angle === 0) {
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                } else {
                    ctx.lineTo(x1, y1);
                }
            }
            ctx.stroke();

            // Draw second strand
            ctx.beginPath();
            for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                const x2 = centerX - radius * Math.cos(angle) * (1 - currentState.z);
                const y2 = centerY + angle * 20 - 200;

                if (angle === 0) {
                    ctx.moveTo(x2, y2);
                } else {
                    ctx.lineTo(x2, y2);
                }
            }
            ctx.stroke();

            // Draw connecting lines
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let angle = 0; angle < Math.PI * 4; angle += Math.PI / 6) {
                const x1 = centerX + radius * Math.cos(angle) * (1 - currentState.z);
                const y1 = centerY + angle * 20 - 200;
                const x2 = centerX - radius * Math.cos(angle) * (1 - currentState.z);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y1);
                ctx.stroke();
            }

            // Draw critical points
            drawCriticalPoint(ctx, centerX, centerY - 100, 'Z_C', Z_CRITICAL);
            drawCriticalPoint(ctx, centerX, centerY, 'Ï†â»Â¹', PHI_INV);
        }

        function getPhaseColor(phase) {
            switch (phase) {
                case 'UNTRUE': return '#ff0000';
                case 'PARADOX': return '#ffff00';
                case 'TRUE': return '#00ff00';
                default: return '#00ff00';
            }
        }

        function drawCriticalPoint(ctx, x, y, label, value) {
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffff00';
            ctx.font = '12px monospace';
            ctx.fillText(`${label}: ${value.toFixed(3)}`, x + 10, y + 5);
        }

        // Chat functionality
        function addUserMessage(message) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message user-message';
            messageEl.textContent = `You: ${message}`;
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function addKiraMessage(message) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message kira-message';
            messageEl.textContent = `KIRA: ${message}`;
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function addSystemMessage(message) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message system-message';
            messageEl.textContent = `System: ${message}`;
            messagesDiv.appendChild(messageEl);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function sendMessage() {
            const input = document.getElementById('user-input');
            const message = input.value.trim();

            if (!message) return;

            addUserMessage(message);

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'kira_chat',
                    message: message
                }));
            } else {
                addSystemMessage('Not connected to server');
            }

            input.value = '';
        }

        // Control actions
        function applyOperator(operator) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'apply_operator',
                    operator: operator
                }));
            }
        }

        function driveToLens() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'drive_to_lens',
                    steps: 100
                }));
                addSystemMessage('Driving toward THE LENS (z_c = âˆš3/2)...');
            }
        }

        function collapse() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'collapse'
                }));
                addSystemMessage('Initiating collapse...');
            }
        }

        function reset() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'reset'
                }));
                addSystemMessage('System reset');
            }
        }

        function toggleAutoMode() {
            const btn = document.getElementById('auto-mode-btn');
            const isActive = btn.classList.toggle('active');

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'toggle_auto_mode',
                    enabled: isActive
                }));
                addSystemMessage(`Auto mode ${isActive ? 'enabled' : 'disabled'}`);
            }
        }

        function toggleTraining() {
            const btn = document.getElementById('training-btn');
            const isActive = btn.classList.toggle('active');

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'toggle_training',
                    enabled: isActive
                }));
                addSystemMessage(`Training ${isActive ? 'started' : 'stopped'}`);
            }
        }

        // Z-slider functionality
        function initZSlider() {
            const slider = document.getElementById('z-slider');
            const handle = document.getElementById('z-slider-handle');
            const fill = document.getElementById('z-slider-fill');
            const valueDisplay = document.getElementById('z-target-value');

            let isDragging = false;

            function updateSlider(clientX) {
                const rect = slider.getBoundingClientRect();
                const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                const zValue = percent;

                handle.style.left = `${percent * 100}%`;
                fill.style.width = `${percent * 100}%`;
                valueDisplay.textContent = zValue.toFixed(3);

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'set_z_target',
                        z: zValue
                    }));
                }
            }

            handle.addEventListener('mousedown', () => {
                isDragging = true;
                handle.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    updateSlider(e.clientX);
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    handle.style.cursor = 'grab';
                }
            });

            slider.addEventListener('click', (e) => {
                if (!isDragging) {
                    updateSlider(e.clientX);
                }
            });
        }

        function handleTrainingUpdate(data) {
            if (data.status === 'started') {
                addSystemMessage(`Training started: ${data.config.name}`);
            } else if (data.status === 'completed') {
                addSystemMessage(`Training completed: Loss=${data.loss.toFixed(4)}`);
            } else if (data.status === 'error') {
                addSystemMessage(`Training error: ${data.error}`);
            }
        }

        function hideLoading() {
            const overlay = document.getElementById('loading-overlay');
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 500);
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize sacred geometry
            initSacredGeometry();

            // Initialize controls
            initZSlider();

            // Chat controls
            document.getElementById('send-button').addEventListener('click', sendMessage);
            document.getElementById('user-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });

            // Control buttons
            document.getElementById('drive-lens-btn').addEventListener('click', driveToLens);
            document.getElementById('collapse-btn').addEventListener('click', collapse);
            document.getElementById('reset-btn').addEventListener('click', reset);
            document.getElementById('auto-mode-btn').addEventListener('click', toggleAutoMode);
            document.getElementById('training-btn').addEventListener('click', toggleTraining);

            // Connect WebSocket
            connectWebSocket();

            // Start visualization animation
            setInterval(updateVisualization, 50);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            initSacredGeometry();
            updateVisualization();
        });
    </script>
</body>
</html>