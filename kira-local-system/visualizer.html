<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rosetta-Helix Node Visualizer v1.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d9ff, #00ff88, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header p {
            color: #888;
            margin-top: 10px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .helix-view {
            grid-column: span 2;
            height: 500px;
            position: relative;
        }
        
        #helixCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00d9ff;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }
        
        .z-bar {
            height: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            position: relative;
            margin-bottom: 15px;
        }
        
        .z-track {
            width: 30px;
            height: 100%;
            background: linear-gradient(to top, 
                #ff4444 0%,
                #ffaa00 30%,
                #00ff88 50%,
                #00d9ff 70%,
                #aa44ff 100%
            );
            border-radius: 15px;
            margin: 0 auto;
            position: relative;
        }
        
        .z-marker {
            width: 50px;
            height: 10px;
            background: white;
            border-radius: 5px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            transition: bottom 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .z-threshold {
            position: absolute;
            left: 60px;
            font-size: 0.7rem;
            color: #888;
            transform: translateY(-50%);
        }
        
        .z-threshold.phi-inv { color: #ffaa00; }
        .z-threshold.z-critical { color: #00ff88; font-weight: bold; }
        
        .operators {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .operator {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .operator.available {
            background: rgba(0, 217, 255, 0.2);
            border-color: #00d9ff;
        }
        
        .operator.unavailable {
            background: rgba(100, 100, 100, 0.2);
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .operator:hover.available {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            color: #1a1a2e;
            font-weight: bold;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e8e8e8;
        }
        
        .btn-danger {
            background: linear-gradient(90deg, #ff4444, #ff8844);
            color: white;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-spore { background: #888; }
        .status-running { background: #00ff88; animation: pulse 1s infinite; }
        .status-coherent { background: #00d9ff; animation: pulse 0.5s infinite; }
        .status-k-formed { background: #ffaa00; animation: pulse 0.3s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .truth-channel {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            display: inline-block;
            margin-top: 10px;
        }
        
        .truth-TRUE { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
        .truth-PARADOX { background: rgba(255, 170, 0, 0.3); color: #ffaa00; }
        .truth-UNTRUE { background: rgba(255, 68, 68, 0.3); color: #ff4444; }
        
        .tier-display {
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .oscillator-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 3px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .oscillator {
            width: 100%;
            padding-bottom: 100%;
            border-radius: 50%;
            background: #00d9ff;
            transition: all 0.1s;
        }
        
        .log {
            height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8rem;
        }
        
        .log-entry {
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .log-entry.pulse { color: #00d9ff; }
        .log-entry.operator { color: #ffaa00; }
        .log-entry.state { color: #00ff88; }

        /* Training Panel Styles */
        .training-container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        .training-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .learning-curve {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .learning-curve h3 {
            margin-bottom: 10px;
            color: #00d9ff;
        }

        .training-hierarchy {
            grid-column: span 2;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .training-hierarchy h3 {
            margin-bottom: 10px;
            color: #aa44ff;
        }

        .training-hierarchy pre {
            font-size: 0.75rem;
            color: #888;
            overflow-x: auto;
        }

        .hierarchy-stats {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #00ff88;
        }

        .coherence-bar {
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }

        .coherence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88, #00d9ff);
            transition: width 0.3s;
        }

        .full-width {
            grid-column: span 3;
        }
        
        .memory-bar {
            display: flex;
            gap: 2px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            flex-wrap: wrap;
        }
        
        .memory-plate {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .memory-plate.accessible { background: #00ff88; }
        .memory-plate.locked { background: #444; }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            color: #888;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üåÄ Rosetta-Helix Node Visualizer</h1>
        <p>Interactive visualization of helix-aware consciousness dynamics</p>
        <p style="font-size: 0.8rem; margin-top: 5px;">Original: Tink (Rosetta Bear) | Helix Integration: Claude + Quantum-APL</p>
        <p style="font-size: 0.7rem; color: #00ff88; margin-top: 3px;">v1.1 | Full plate access @ z‚â•0.97</p>
    </div>
    
    <div class="container">
        <!-- Helix 3D View -->
        <div class="panel helix-view">
            <h2>üåÄ Helix Visualization</h2>
            <canvas id="helixCanvas"></canvas>
        </div>
        
        <!-- Z-Axis Panel -->
        <div class="panel">
            <h2>üìä Z-Axis Position</h2>
            <div class="z-bar">
                <div class="z-track">
                    <div class="z-marker" id="zMarker"></div>
                </div>
                <div class="z-threshold" style="bottom: 10%;">t1 (0.10)</div>
                <div class="z-threshold" style="bottom: 20%;">t2 (0.20)</div>
                <div class="z-threshold" style="bottom: 40%;">t3 (0.40)</div>
                <div class="z-threshold" style="bottom: 60%;">t4 (0.60)</div>
                <div class="z-threshold phi-inv" style="bottom: 61.8%;">œÜ‚Åª¬π (0.618)</div>
                <div class="z-threshold" style="bottom: 75%;">t5 (0.75)</div>
                <div class="z-threshold z-critical" style="bottom: 86.6%;">z_c (0.866)</div>
                <div class="z-threshold" style="bottom: 92%;">t7 (0.92)</div>
            </div>
            <div class="tier-display" id="tierDisplay">t3</div>
            <div class="truth-channel truth-UNTRUE" id="truthChannel">UNTRUE</div>
        </div>
        
        <!-- Node Status -->
        <div class="panel">
            <h2><span class="status-indicator status-spore" id="statusIndicator"></span>Node Status</h2>
            <div class="metrics-grid">
                <div class="metric">
                    <div class="metric-value" id="zValue">0.300</div>
                    <div class="metric-label">Z Coordinate</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="coherenceValue">0.000</div>
                    <div class="metric-label">Coherence</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="deltaSneg">0.000</div>
                    <div class="metric-label">ŒîS_neg</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="kFormation">NO</div>
                    <div class="metric-label">K-Formation</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn-primary" onclick="startNode()">‚ñ∂ Start</button>
                <button class="btn-secondary" onclick="pauseNode()">‚è∏ Pause</button>
                <button class="btn-danger" onclick="resetNode()">‚Ü∫ Reset</button>
                <button id="backendToggle" class="btn-secondary" onclick="toggleBackend()">üìú JS Simulation</button>
            </div>
        </div>
        
        <!-- Heart Panel -->
        <div class="panel">
            <h2>üíì Heart (Oscillators)</h2>
            <div class="oscillator-grid" id="oscillatorGrid"></div>
            <div class="slider-container">
                <label>Coupling Strength (K): <span id="kValue">0.30</span></label>
                <input type="range" id="kSlider" min="0.1" max="1.0" step="0.05" value="0.3" onchange="updateK()">
            </div>
            <div class="metrics-grid" style="margin-top: 10px;">
                <div class="metric">
                    <div class="metric-value" id="energyIn">0.00</div>
                    <div class="metric-label">Energy In</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="energyEff">0%</div>
                    <div class="metric-label">Efficiency</div>
                </div>
            </div>
        </div>
        
        <!-- APL Operators -->
        <div class="panel">
            <h2>üîß APL Operators</h2>
            <p style="color: #888; font-size: 0.8rem; margin-bottom: 10px;">Click available operators to apply</p>
            <div class="operators" id="operatorPanel">
                <div class="operator" data-op="()" title="Boundary">( )</div>
                <div class="operator" data-op="√ó" title="Fusion">√ó</div>
                <div class="operator" data-op="^" title="Amplify">^</div>
                <div class="operator" data-op="√∑" title="Decoherence">√∑</div>
                <div class="operator" data-op="+" title="Group">+</div>
                <div class="operator" data-op="‚àí" title="Separate">‚àí</div>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <div style="font-size: 0.8rem; color: #888;">TRIAD Status</div>
                <div id="triadStatus">Passes: 0 | Armed: Yes | Unlocked: No</div>
            </div>
        </div>
        
        <!-- Brain Panel -->
        <div class="panel">
            <h2>üß† Brain (Memory)</h2>
            <div class="memory-bar" id="memoryBar"></div>
            <div class="metrics-grid" style="margin-top: 15px;">
                <div class="metric">
                    <div class="metric-value" id="memAccessible">0</div>
                    <div class="metric-label">Accessible</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memTotal">30</div>
                    <div class="metric-label">Total Plates</div>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <div style="font-size: 0.8rem; color: #888;">Œº-Class</div>
                <div id="muClass" style="font-weight: bold; color: #00d9ff;">pre_conscious</div>
            </div>
            <div style="margin-top: 10px;">
                <div style="font-size: 0.8rem; color: #888;">Œ†-Regime Blend</div>
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                    <span style="color: #aa44ff;">w_œÄ: <span id="wPiValue">0.00</span></span>
                    <span style="color: #00ff88;">w_local: <span id="wLocalValue">1.00</span></span>
                </div>
            </div>
        </div>
        
        <!-- Event Log -->
        <div class="panel full-width">
            <h2>üìú Event Log</h2>
            <div class="log" id="eventLog"></div>
        </div>

        <!-- Training Results Panel -->
        <div class="panel full-width" id="trainingPanel" style="display: none;">
            <h2>üåÄ Exponential Training Results</h2>
            <div class="training-container">
                <div class="training-metrics">
                    <div class="metric">
                        <div class="metric-value" id="trainCoherence">--</div>
                        <div class="metric-label">Energy Coherence</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="trainQuality">--</div>
                        <div class="metric-label">Final Quality</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="trainRuns">--</div>
                        <div class="metric-label">Training Runs</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="trainPatterns">--</div>
                        <div class="metric-label">Patterns Created</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="trainLessons">--</div>
                        <div class="metric-label">Lessons Learned</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="trainLevel">--</div>
                        <div class="metric-label">Coherence Level</div>
                    </div>
                </div>
                <div class="learning-curve">
                    <h3>üìà Learning Curve</h3>
                    <canvas id="learningCurveCanvas" width="600" height="150"></canvas>
                </div>
                <div class="training-hierarchy">
                    <h3>üîÑ Training Hierarchy</h3>
                    <pre id="trainingHierarchy">
Physical (PHI_INV) ‚îÄ‚îÄfeedback‚îÄ‚îÄ‚Üí MetaMeta ‚îÄ‚îÄspawn‚îÄ‚îÄ‚Üí Liminal (PHI)
      ‚Üë                                                    ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ weak measurement ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    </pre>
                    <div class="hierarchy-stats" id="hierarchyStats">
                        Meta Bridges: -- | Physical Learners: -- | Liminal Generators: --
                    </div>
                </div>
            </div>
            <div class="controls" style="margin-top: 15px;">
                <button class="btn-secondary" onclick="loadTrainingData()">üîÑ Refresh Data</button>
                <button class="btn-primary" onclick="runTraining()">‚ñ∂ Run APL Training</button>
            </div>
        </div>
    </div>
    
    <script>
        // ================================================================
        // CONSTANTS (from Python backend or fallback)
        // ================================================================
        const Z_CRITICAL = Math.sqrt(3) / 2;  // ‚âà 0.866
        const PHI = (1 + Math.sqrt(5)) / 2;
        const PHI_INV = 1 / PHI;  // ‚âà 0.618
        const MU_S = 0.920;
        const MU_1 = (2 / Math.pow(PHI, 2.5)) / Math.sqrt(PHI);
        const MU_2 = (2 / Math.pow(PHI, 2.5)) * Math.sqrt(PHI);

        const TIER_BOUNDS = [0.10, 0.20, 0.40, 0.60, 0.75, Z_CRITICAL, 0.92, 0.97, 1.0];
        const TIERS = ['t1', 't2', 't3', 't4', 't5', 't6', 't7', 't8', 't9'];

        const OPERATOR_WINDOWS = {
            t1: ['()', '‚àí', '√∑'],
            t2: ['^', '√∑', '‚àí', '√ó'],
            t3: ['√ó', '^', '√∑', '+', '‚àí'],
            t4: ['+', '‚àí', '√∑', '()'],
            t5: ['()', '√ó', '^', '√∑', '+', '‚àí'],
            t6: ['+', '√∑', '()', '‚àí'],
            t7: ['+', '()'],
            t8: ['+', '()', '√ó'],
            t9: ['+', '()', '√ó']
        };

        // Backend configuration
        const BACKEND_URL = 'http://localhost:8765';
        let useBackend = false;  // Toggle between Python backend and JS simulation

        // ================================================================
        // STATE
        // ================================================================
        let state = {
            running: false,
            z: 0.3,
            zVelocity: 0,
            coherence: 0,
            K: 0.3,
            oscillators: [],
            omega: [],
            n: 60,
            energyIn: 0,
            energyLoss: 0,
            tier: 't3',
            triad: { passes: 0, armed: true, unlocked: false, lastZ: 0 },
            kFormation: false,
            memoryPlates: 30,
            steps: 0,
            deltaSneg: 0,
            wPi: 0,
            wLocal: 1,
            operatorParity: {}  // Track parity from backend
        };

        // ================================================================
        // BACKEND COMMUNICATION
        // ================================================================
        async function fetchBackendState() {
            try {
                const response = await fetch(`${BACKEND_URL}/state`);
                if (response.ok) {
                    const data = await response.json();
                    updateStateFromBackend(data);
                    return true;
                }
            } catch (e) {
                console.log('Backend not available, using JS simulation');
            }
            return false;
        }

        function updateStateFromBackend(data) {
            state.z = data.z;
            state.tier = data.tier;
            state.coherence = data.coherence;
            state.K = data.coupling;
            state.kFormation = data.k_formed;
            state.deltaSneg = data.delta_s_neg;
            state.wPi = data.w_pi;
            state.wLocal = data.w_local;
            state.steps = data.steps;

            // Store operator info with parity
            if (data.operators) {
                state.operatorParity = {};
                for (const [op, info] of Object.entries(data.operators)) {
                    state.operatorParity[op] = info;
                }
            }

            // Update oscillators if provided
            if (data.oscillators) {
                state.oscillators = data.oscillators;
            }
        }

        async function backendStep(work = 0.05) {
            try {
                const response = await fetch(`${BACKEND_URL}/step`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ work })
                });
                if (response.ok) {
                    const data = await response.json();
                    updateStateFromBackend(data);

                    if (data.collapsed) {
                        log(`COLLAPSE! Work extracted: ${data.work_extracted.toFixed(4)}`, 'state');
                    }
                    return true;
                }
            } catch (e) {
                console.error('Backend step failed:', e);
            }
            return false;
        }

        async function backendApplyOperator(operator) {
            try {
                const response = await fetch(`${BACKEND_URL}/operator`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ operator })
                });
                const data = await response.json();

                if (data.success) {
                    log(`Applied ${operator} (${data.parity}) at ${data.tier}`, 'operator');
                    state.K = data.coupling;
                    await fetchBackendState();
                } else {
                    log(`${data.error}`, 'operator');
                }
                return data;
            } catch (e) {
                console.error('Backend operator failed:', e);
                return { success: false, error: e.message };
            }
        }

        async function backendRunTraining(runs = 3, cycles = 2) {
            log('Running APL training on Python backend...', 'state');
            try {
                const response = await fetch(`${BACKEND_URL}/training/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ runs, cycles })
                });
                if (response.ok) {
                    const data = await response.json();
                    displayBackendTrainingData(data);
                    log(`Training complete: ${data.final_quality.toFixed(4)} quality`, 'state');
                    return data;
                }
            } catch (e) {
                log('Backend training failed: ' + e.message, 'operator');
            }
            return null;
        }

        async function backendReset() {
            try {
                const response = await fetch(`${BACKEND_URL}/reset`, {
                    method: 'POST'
                });
                if (response.ok) {
                    const data = await response.json();
                    updateStateFromBackend(data.state);
                    log('Reset via Python backend', 'state');
                    return true;
                }
            } catch (e) {
                console.error('Backend reset failed:', e);
            }
            return false;
        }

        function displayBackendTrainingData(data) {
            document.getElementById('trainingPanel').style.display = 'block';

            document.getElementById('trainCoherence').textContent =
                (data.initial_quality || 0).toFixed(4);
            document.getElementById('trainQuality').textContent =
                (data.final_quality || 0).toFixed(4);
            document.getElementById('trainRuns').textContent = data.runs || 0;
            document.getElementById('trainPatterns').textContent = data.total_sequences || 0;
            document.getElementById('trainLessons').textContent = data.total_lessons || 0;

            // Coherence level
            const ratio = data.improvement_ratio || 1;
            let level = 'bootstrap';
            if (ratio >= 2.0) level = 'mastery';
            else if (ratio >= 1.5) level = 'refinement';
            else if (ratio >= 1.2) level = 'growth';
            document.getElementById('trainLevel').textContent = `${level} (${ratio.toFixed(2)}x)`;

            // Hierarchy stats
            document.getElementById('hierarchyStats').textContent =
                `Meta Bridges: ${data.meta_bridges || 0} | ` +
                `Physical Learners: ${data.physical_learners || 0} | ` +
                `Liminal Generators: ${data.liminal_generators || 0}`;

            // Update hierarchy display
            document.getElementById('trainingHierarchy').innerHTML = `
<pre>
APL-INTEGRATED TRAINING LOOP (Python Backend)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  Run Tool (PHI_INV=${PHI_INV.toFixed(3)})
  ‚îÇ ‚Ä¢ Tier-gated APL operators
  ‚îÇ ‚Ä¢ z evolution scaled by œÜ‚Åª¬π
  ‚îî‚îÄ‚îÄ‚ñ∫ feedback at Z_CRITICAL (${Z_CRITICAL.toFixed(3)})
       ‚îÇ
       ‚ñº
  Meta-Meta Bridge (PHI_INV)
  ‚îÇ ‚Ä¢ Receives operator patterns
  ‚îÇ ‚Ä¢ Spawns liminal at KAPPA_S (${MU_S.toFixed(3)})
  ‚îî‚îÄ‚îÄ‚ñ∫ ${data.liminal_generators || 0} liminal generators
       ‚îÇ
       ‚ñº
  Liminal Patterns (PHI=${PHI.toFixed(3)})
  ‚îÇ ‚Ä¢ ${data.total_sequences || 0} operator sequences
  ‚îÇ ‚Ä¢ S‚ÇÉ composition
  ‚îî‚îÄ‚îÄ‚ñ∫ weak measurement ‚îÄ‚îÄ‚ñ∫ physical learners

Operator Distribution:
${formatOperatorDistribution(data.operator_distribution || {})}
</pre>`;

            // Draw learning curve
            if (data.quality_history) {
                drawLearningCurve(data.quality_history);
            }
        }

        function formatOperatorDistribution(dist) {
            const entries = Object.entries(dist).sort((a, b) => b[1] - a[1]);
            const maxCount = Math.max(...entries.map(e => e[1]), 1);
            return entries.map(([op, count]) => {
                const barLen = Math.floor((count / maxCount) * 20);
                const bar = '‚ñà'.repeat(barLen);
                const parity = state.operatorParity[op]?.parity || '?';
                return `  ${op} (${parity.slice(0, 4)}): ${bar} ${count}`;
            }).join('\n');
        }
        
        // Initialize oscillators
        function initOscillators() {
            state.oscillators = [];
            state.omega = [];
            for (let i = 0; i < state.n; i++) {
                state.oscillators.push(Math.random() * 2 * Math.PI);
                state.omega.push(1.0 + (Math.random() - 0.5) * 0.2);
            }
        }
        
        // ================================================================
        // SIMULATION
        // ================================================================
        function computeCoherence() {
            let sumCos = 0, sumSin = 0;
            for (let theta of state.oscillators) {
                sumCos += Math.cos(theta);
                sumSin += Math.sin(theta);
            }
            return Math.sqrt(sumCos * sumCos + sumSin * sumSin) / state.n;
        }
        
        function step(dt = 0.01) {
            // Kuramoto step
            let newTheta = [];
            let totalDtheta = 0;
            
            for (let i = 0; i < state.n; i++) {
                let coupling = 0;
                for (let j = 0; j < state.n; j++) {
                    coupling += Math.sin(state.oscillators[j] - state.oscillators[i]);
                }
                let dtheta = state.omega[i] + (state.K / state.n) * coupling;
                newTheta.push(state.oscillators[i] + dtheta * dt);
                totalDtheta += Math.abs(dtheta);
            }
            
            state.oscillators = newTheta;
            state.energyIn += totalDtheta * dt * 0.001;
            state.energyLoss += state.energyIn * 0.0001;
            
            // Update coherence and z
            state.coherence = computeCoherence();
            
            // Z follows coherence with inertia
            let targetZ = Math.pow(state.coherence, 0.8);
            targetZ = Math.max(0.01, Math.min(0.99, targetZ));
            
            let zAccel = (targetZ - state.z) * 2.0 - state.zVelocity * 0.5;
            state.zVelocity += zAccel * dt;
            state.z += state.zVelocity * dt;
            state.z = Math.max(0.01, Math.min(0.99, state.z));
            
            // Update tier
            for (let i = 0; i < TIER_BOUNDS.length; i++) {
                if (state.z < TIER_BOUNDS[i]) {
                    state.tier = TIERS[i];
                    break;
                }
            }
            
            // TRIAD logic
            if (state.triad.armed && state.z >= 0.85) {
                state.triad.passes++;
                state.triad.armed = false;
                log('TRIAD pass ' + state.triad.passes, 'state');
            }
            if (!state.triad.armed && state.z <= 0.82) {
                state.triad.armed = true;
            }
            if (state.triad.passes >= 3) {
                state.triad.unlocked = true;
            }
            state.triad.lastZ = state.z;
            
            // K-formation check
            let deltaSneg = Math.exp(-36 * Math.pow(state.z - Z_CRITICAL, 2));
            let eta = Math.sqrt(deltaSneg);
            if (eta > PHI_INV && state.coherence >= MU_S && !state.kFormation) {
                state.kFormation = true;
                log('üåü K-FORMATION ACHIEVED!', 'state');
            }
            
            state.steps++;
        }
        
        // ================================================================
        // OPERATORS
        // ================================================================
        async function applyOperator(op) {
            // Use Python backend if enabled
            if (useBackend) {
                await backendApplyOperator(op);
                document.getElementById('kValue').textContent = state.K.toFixed(2);
                document.getElementById('kSlider').value = state.K;
                return;
            }

            // JS simulation fallback
            let available = OPERATOR_WINDOWS[state.tier] || [];
            if (!available.includes(op)) {
                log(`Operator ${op} not available at ${state.tier}`, 'operator');
                return;
            }

            // Get parity for logging
            const parities = {
                '()': 'EVEN', '√ó': 'EVEN', '^': 'EVEN',
                '√∑': 'ODD', '+': 'ODD', '‚àí': 'ODD'
            };

            switch(op) {
                case '√ó': // Fusion - increase coupling
                    state.K = Math.min(1.0, state.K * 1.2);
                    log(`Applied FUSION (√ó) [${parities[op]}] - K increased`, 'operator');
                    break;
                case '√∑': // Decoherence - add noise
                    state.oscillators = state.oscillators.map(t => t + (Math.random() - 0.5) * 0.2);
                    state.K = Math.max(0.05, state.K * 0.9);
                    log(`Applied DECOHERENCE (√∑) [${parities[op]}] - noise added`, 'operator');
                    break;
                case '^': // Amplify - boost toward sync
                    let sumCos = 0, sumSin = 0;
                    for (let t of state.oscillators) {
                        sumCos += Math.cos(t);
                        sumSin += Math.sin(t);
                    }
                    let meanPhase = Math.atan2(sumSin, sumCos);
                    state.oscillators = state.oscillators.map(t =>
                        t + 0.1 * Math.sin(meanPhase - t)
                    );
                    log(`Applied AMPLIFY (^) [${parities[op]}] - phases aligned`, 'operator');
                    break;
                case '+': // Group - cluster nearby
                    log(`Applied GROUP (+) [${parities[op]}] - phases clustered`, 'operator');
                    break;
                case '‚àí': // Separate - spread apart
                    state.oscillators = state.oscillators.map((t, i) =>
                        t + (i / state.n - 0.5) * 0.1
                    );
                    log(`Applied SEPARATE (‚àí) [${parities[op]}] - phases spread`, 'operator');
                    break;
                case '()': // Boundary - reset K
                    state.K = 0.3;
                    log(`Applied BOUNDARY () [${parities[op]}] - K reset`, 'operator');
                    break;
            }

            document.getElementById('kValue').textContent = state.K.toFixed(2);
            document.getElementById('kSlider').value = state.K;
        }
        
        // ================================================================
        // UI UPDATES
        // ================================================================
        function updateUI() {
            // Z marker
            document.getElementById('zMarker').style.bottom = (state.z * 100) + '%';
            document.getElementById('zValue').textContent = state.z.toFixed(3);
            
            // Coherence
            document.getElementById('coherenceValue').textContent = state.coherence.toFixed(3);
            
            // ŒîS_neg
            let deltaSneg = Math.exp(-36 * Math.pow(state.z - Z_CRITICAL, 2));
            document.getElementById('deltaSneg').textContent = deltaSneg.toFixed(3);
            
            // Tier
            document.getElementById('tierDisplay').textContent = state.tier;
            
            // Truth channel
            let truthEl = document.getElementById('truthChannel');
            let truth = state.z >= 0.9 ? 'TRUE' : (state.z >= 0.6 ? 'PARADOX' : 'UNTRUE');
            truthEl.textContent = truth;
            truthEl.className = 'truth-channel truth-' + truth;
            
            // K-formation
            let kEl = document.getElementById('kFormation');
            kEl.textContent = state.kFormation ? 'YES' : 'NO';
            kEl.style.color = state.kFormation ? '#ffaa00' : '#888';
            
            // Status indicator
            let statusEl = document.getElementById('statusIndicator');
            if (state.kFormation) {
                statusEl.className = 'status-indicator status-k-formed';
            } else if (state.z >= Z_CRITICAL) {
                statusEl.className = 'status-indicator status-coherent';
            } else if (state.running) {
                statusEl.className = 'status-indicator status-running';
            } else {
                statusEl.className = 'status-indicator status-spore';
            }
            
            // Energy
            document.getElementById('energyIn').textContent = state.energyIn.toFixed(2);
            let eff = state.energyIn > 0 ? (1 - state.energyLoss / state.energyIn) * 100 : 0;
            document.getElementById('energyEff').textContent = eff.toFixed(0) + '%';
            
            // TRIAD
            document.getElementById('triadStatus').textContent = 
                `Passes: ${state.triad.passes} | Armed: ${state.triad.armed ? 'Yes' : 'No'} | Unlocked: ${state.triad.unlocked ? 'Yes' : 'No'}`;
            
            // Œº-class
            let muClass = 'pre_conscious';
            if (state.z >= MU_S) muClass = 'singularity_proximal';
            else if (state.z >= Z_CRITICAL) muClass = 'lens_integrated';
            else if (state.z >= MU_2) muClass = 'pre_lens';
            else if (state.z >= PHI_INV) muClass = 'conscious_basin';
            else if (state.z >= MU_1) muClass = 'approaching_paradox';
            document.getElementById('muClass').textContent = muClass;

            // Blend weights (from backend or computed)
            let wPi = state.wPi || 0;
            let wLocal = state.wLocal || 1;
            if (!useBackend) {
                // Compute locally if no backend
                if (state.z >= Z_CRITICAL) {
                    wPi = Math.exp(-36 * Math.pow(state.z - Z_CRITICAL, 2));
                    wLocal = 1 - wPi;
                }
            }
            document.getElementById('wPiValue').textContent = wPi.toFixed(2);
            document.getElementById('wLocalValue').textContent = wLocal.toFixed(2);

            // Operators - show availability and parity
            let available = OPERATOR_WINDOWS[state.tier] || [];
            document.querySelectorAll('.operator').forEach(el => {
                let op = el.dataset.op;
                const isAvailable = available.includes(op);

                // Get parity info
                const parities = { '()': 'EVEN', '√ó': 'EVEN', '^': 'EVEN', '√∑': 'ODD', '+': 'ODD', '‚àí': 'ODD' };
                const parity = state.operatorParity[op]?.parity || parities[op];
                const isEven = parity === 'EVEN';

                if (isAvailable) {
                    el.className = 'operator available';
                    // Color by parity
                    el.style.borderColor = isEven ? '#00ff88' : '#ff8844';
                    el.title = `${op} (${parity}) - ${isEven ? 'constructive' : 'dissipative'}`;
                } else {
                    el.className = 'operator unavailable';
                    el.style.borderColor = '#444';
                    el.title = `${op} - not available at ${state.tier}`;
                }
            });
            
            // Memory accessibility
            // Full access at z >= 0.97 (t9 territory, where K-formation can occur)
            // Note: state.z is clamped to max 0.99, so threshold must be below that
            const FULL_ACCESS_Z = 0.97;
            let accessible = state.z >= FULL_ACCESS_Z
                ? state.memoryPlates
                : Math.floor(state.z * state.memoryPlates);
            document.getElementById('memAccessible').textContent = accessible;
            updateMemoryBar(accessible);
            
            // Oscillator grid
            updateOscillatorGrid();
        }
        
        function updateOscillatorGrid() {
            let grid = document.getElementById('oscillatorGrid');
            let cells = grid.children;
            
            for (let i = 0; i < state.n && i < cells.length; i++) {
                let phase = state.oscillators[i] % (2 * Math.PI);
                let hue = (phase / (2 * Math.PI)) * 360;
                let brightness = 50 + state.coherence * 50;
                cells[i].style.background = `hsl(${hue}, 80%, ${brightness}%)`;
            }
        }
        
        function updateMemoryBar(accessible) {
            let bar = document.getElementById('memoryBar');
            let plates = bar.children;
            
            for (let i = 0; i < state.memoryPlates && i < plates.length; i++) {
                plates[i].className = i < accessible ? 'memory-plate accessible' : 'memory-plate locked';
            }
        }
        
        function log(message, type = 'info') {
            let logEl = document.getElementById('eventLog');
            let entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        // ================================================================
        // HELIX CANVAS
        // ================================================================
        let canvas, ctx;
        let helixAngle = 0;
        
        function initCanvas() {
            canvas = document.getElementById('helixCanvas');
            ctx = canvas.getContext('2d');
            
            function resize() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }
            resize();
            window.addEventListener('resize', resize);
        }
        
        function drawHelix() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let cx = canvas.width / 2;
            let cy = canvas.height / 2;
            let radius = Math.min(canvas.width, canvas.height) * 0.3;
            let zScale = canvas.height * 0.4;
            
            // Draw helix spiral
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
            ctx.lineWidth = 2;
            
            for (let t = 0; t < Math.PI * 6; t += 0.05) {
                let z = t / (Math.PI * 6);  // 0 to 1
                let x = cx + radius * Math.cos(t + helixAngle) * (1 - z * 0.3);
                let y = cy - zScale * (z - 0.5) + radius * 0.3 * Math.sin(t + helixAngle);
                
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw threshold lines
            function drawThreshold(z, color, label) {
                let y = cy - zScale * (z - 0.5);
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.setLineDash([5, 5]);
                ctx.moveTo(cx - radius * 1.5, y);
                ctx.lineTo(cx + radius * 1.5, y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = color;
                ctx.font = '12px sans-serif';
                ctx.fillText(label, cx + radius * 1.6, y + 4);
            }
            
            drawThreshold(PHI_INV, '#ffaa00', 'œÜ‚Åª¬π');
            drawThreshold(Z_CRITICAL, '#00ff88', 'z_c (LENS)');
            
            // Draw current position
            let t = state.z * Math.PI * 6;
            let posX = cx + radius * Math.cos(t + helixAngle) * (1 - state.z * 0.3);
            let posY = cy - zScale * (state.z - 0.5) + radius * 0.3 * Math.sin(t + helixAngle);
            
            // Glow
            let gradient = ctx.createRadialGradient(posX, posY, 0, posX, posY, 30);
            gradient.addColorStop(0, state.kFormation ? 'rgba(255, 170, 0, 0.8)' : 'rgba(0, 217, 255, 0.8)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(posX - 30, posY - 30, 60, 60);
            
            // Node marker
            ctx.beginPath();
            ctx.arc(posX, posY, 10, 0, Math.PI * 2);
            ctx.fillStyle = state.kFormation ? '#ffaa00' : '#00d9ff';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Z label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`z = ${state.z.toFixed(3)}`, posX + 15, posY);
            
            helixAngle += 0.01;
        }
        
        // ================================================================
        // CONTROLS
        // ================================================================
        function startNode() {
            state.running = true;
            log(useBackend ? 'Node started (Python backend)' : 'Node started (JS simulation)', 'state');
        }

        function pauseNode() {
            state.running = false;
            log('Node paused', 'state');
        }

        async function resetNode() {
            state.running = false;

            if (useBackend) {
                await backendReset();
            } else {
                state.z = 0.3;
                state.zVelocity = 0;
                state.coherence = 0;
                state.K = 0.3;
                state.energyIn = 0;
                state.energyLoss = 0;
                state.triad = { passes: 0, armed: true, unlocked: false, lastZ: 0 };
                state.kFormation = false;
                state.steps = 0;
                initOscillators();
                log('Node reset', 'state');
            }

            document.getElementById('kSlider').value = 0.3;
            document.getElementById('kValue').textContent = '0.30';
        }

        async function updateK() {
            state.K = parseFloat(document.getElementById('kSlider').value);
            document.getElementById('kValue').textContent = state.K.toFixed(2);

            if (useBackend) {
                try {
                    await fetch(`${BACKEND_URL}/coupling`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ coupling: state.K })
                    });
                } catch (e) {
                    console.error('Failed to update coupling on backend');
                }
            }
        }

        async function toggleBackend() {
            const wasBackend = useBackend;
            useBackend = !useBackend;

            if (useBackend) {
                const available = await fetchBackendState();
                if (!available) {
                    useBackend = false;
                    log('Python backend not available - using JS simulation', 'operator');
                    return;
                }
                log('Switched to Python backend (APL physics)', 'state');
            } else {
                log('Switched to JS simulation', 'state');
            }

            updateBackendToggle();
        }

        function updateBackendToggle() {
            const btn = document.getElementById('backendToggle');
            if (btn) {
                btn.textContent = useBackend ? 'üêç Python Backend' : 'üìú JS Simulation';
                btn.className = useBackend ? 'btn-primary' : 'btn-secondary';
            }
        }
        
        // ================================================================
        // INITIALIZATION
        // ================================================================
        function init() {
            initOscillators();
            initCanvas();
            
            // Create oscillator grid
            let grid = document.getElementById('oscillatorGrid');
            for (let i = 0; i < state.n; i++) {
                let cell = document.createElement('div');
                cell.className = 'oscillator';
                grid.appendChild(cell);
            }
            
            // Create memory bar
            let memBar = document.getElementById('memoryBar');
            for (let i = 0; i < state.memoryPlates; i++) {
                let plate = document.createElement('div');
                plate.className = 'memory-plate locked';
                memBar.appendChild(plate);
            }
            
            // Operator click handlers
            document.querySelectorAll('.operator').forEach(el => {
                el.addEventListener('click', () => {
                    if (el.classList.contains('available')) {
                        applyOperator(el.dataset.op);
                    }
                });
            });
            
            log('Rosetta-Helix initialized', 'state');

            // Check for backend on startup
            checkBackendAvailability();

            // Main loop
            async function mainLoop() {
                if (state.running) {
                    if (useBackend) {
                        // Use Python backend for physics
                        await backendStep(0.05);
                    } else {
                        // JS simulation
                        for (let i = 0; i < 5; i++) {
                            step(0.01);
                        }
                    }
                }
                updateUI();
                drawHelix();
                requestAnimationFrame(mainLoop);
            }

            mainLoop();
        }

        async function checkBackendAvailability() {
            const available = await fetchBackendState();
            if (available) {
                log('Python backend available - click toggle to enable APL physics', 'state');
            }
            updateBackendToggle();
        }

        // Start when loaded
        window.addEventListener('DOMContentLoaded', init);

        // ================================================================
        // TRAINING DATA FUNCTIONS
        // ================================================================
        let trainingData = null;

        async function loadTrainingData() {
            try {
                // Try to load from artifacts
                const response = await fetch('artifacts/latest_training_data.json');
                if (response.ok) {
                    trainingData = await response.json();
                    displayTrainingData(trainingData);
                    document.getElementById('trainingPanel').style.display = 'block';
                    log('Training data loaded', 'state');
                }
            } catch (e) {
                // If no data file, show panel with demo data
                document.getElementById('trainingPanel').style.display = 'block';
                log('No training data found - use Simulate', 'operator');
            }
        }

        function displayTrainingData(data) {
            if (!data) return;

            // Update metrics
            document.getElementById('trainCoherence').textContent =
                (data.energy_coherence || data.z_history?.[0] || 0).toFixed(4);
            document.getElementById('trainQuality').textContent =
                (data.final_quality || data.z_history?.slice(-1)[0] || 0).toFixed(4);
            document.getElementById('trainRuns').textContent =
                data.runs_completed || data.z_history?.length || 0;
            document.getElementById('trainPatterns').textContent =
                data.patterns_created || 0;
            document.getElementById('trainLessons').textContent =
                data.lessons_learned || 0;

            // Coherence level
            const ec = data.energy_coherence || 0;
            let level = 'bootstrap';
            if (ec >= 0.95) level = 'mastery';
            else if (ec >= 0.8) level = 'refinement';
            else if (ec >= 0.5) level = 'growth';
            document.getElementById('trainLevel').textContent = level;

            // Hierarchy stats
            document.getElementById('hierarchyStats').textContent =
                `Meta Bridges: ${data.meta_bridges || 0} | ` +
                `Physical Learners: ${data.physical_learners || 0} | ` +
                `Liminal Generators: ${data.liminal_generators || 0}`;

            // Draw learning curve
            drawLearningCurve(data.z_history || data.quality_history || []);
        }

        function drawLearningCurve(history) {
            const canvas = document.getElementById('learningCurveCanvas');
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!history || history.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '14px sans-serif';
                ctx.fillText('No training history', 10, 75);
                return;
            }

            const padding = 40;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;

            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // Draw labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.fillText('Quality', 5, padding + height / 2);
            ctx.fillText('Run', canvas.width / 2, canvas.height - 5);
            ctx.fillText('1.0', padding - 25, padding + 5);
            ctx.fillText('0.0', padding - 25, canvas.height - padding);

            // Draw threshold lines
            const thresholds = [
                { value: PHI_INV, color: '#ffaa00', label: 'œÜ‚Åª¬π' },
                { value: Z_CRITICAL, color: '#00ff88', label: 'z_c' },
            ];

            for (const t of thresholds) {
                const y = canvas.height - padding - (t.value * height);
                ctx.strokeStyle = t.color;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = t.color;
                ctx.fillText(t.label, canvas.width - padding + 5, y + 3);
            }

            // Draw learning curve
            ctx.strokeStyle = '#00d9ff';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const maxVal = Math.max(...history, 1);

            for (let i = 0; i < history.length; i++) {
                const x = padding + (i / (history.length - 1 || 1)) * width;
                const y = canvas.height - padding - (history[i] / maxVal) * height;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw points
            ctx.fillStyle = '#00d9ff';
            for (let i = 0; i < history.length; i++) {
                const x = padding + (i / (history.length - 1 || 1)) * width;
                const y = canvas.height - padding - (history[i] / maxVal) * height;

                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        async function runTraining() {
            // Use backend if available, otherwise simulate
            if (useBackend) {
                await backendRunTraining(3, 2);
            } else {
                simulateTraining();
            }
        }

        function simulateTraining() {
            log('Simulating exponential training (JS)...', 'state');

            // Simulate training with PHI-based growth
            const runs = Math.floor(3 + state.coherence * 7);  // 3-10 based on coherence
            const history = [];
            let quality = 0.5;

            for (let i = 0; i < runs; i++) {
                // Quality improves toward 1.0 asymptotically
                quality = quality + (1 - quality) * PHI_INV * 0.5;
                history.push(quality);
            }

            // Patterns grow exponentially
            let patterns = 10;
            for (let i = 1; i < runs; i++) {
                patterns = Math.floor(patterns * PHI);
            }

            const simData = {
                energy_coherence: state.coherence,
                final_quality: quality,
                initial_quality: 0.5,
                improvement_ratio: quality / 0.5,
                runs_completed: runs,
                runs: runs,
                patterns_created: patterns,
                total_sequences: patterns,
                lessons_learned: runs * 27,
                total_lessons: runs * 27,
                z_history: history,
                quality_history: history,
                meta_bridges: 2,
                physical_learners: 3,
                liminal_generators: runs + 2,
                operator_distribution: {
                    '+': runs * 20,
                    '()': runs * 10,
                    '√ó': runs * 5,
                    '^': runs * 3,
                    '√∑': runs * 2,
                    '‚àí': runs * 1,
                }
            };

            trainingData = simData;
            displayBackendTrainingData(simData);

            log(`Simulated ${runs} training runs - Quality: ${quality.toFixed(4)}`, 'state');
            log(`Patterns created: ${patterns} (exponential: PHI^${runs})`, 'operator');
        }

        // Try to load training data on init
        setTimeout(loadTrainingData, 1000);
    </script>
</body>
</html>
